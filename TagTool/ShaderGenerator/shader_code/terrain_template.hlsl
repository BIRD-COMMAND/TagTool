#define terrain_template
#include "terrain_template_methods/template_default_defs.hlsl"
#include "terrain_template_methods/template_includes.hlsl"
#include "helpers.hlsl"

struct VS_OUTPUT
{
    float4 TexCoord : TEXCOORD;
    float4 TexCoord1 : TEXCOORD1;
    float4 TexCoord2 : TEXCOORD2;
    float4 TexCoord3 : TEXCOORD3;
};

struct PS_OUTPUT
{
    float4 Diffuse;
#ifndef flag_bump_mapping_leave
    float4 Normal;
    float4 Unknown;
#endif
};

PS_OUTPUT main(VS_OUTPUT input) : COLOR
{
	float2 texcoord = input.TexCoord.xy;
	// Untested, its possible these tangents are reversed
	float3 tangentspace_x = input.TexCoord1.xyz;
	float3 tangentspace_y = input.TexCoord2.xyz;
	float3 tangentspace_z = input.TexCoord3.xyz;
	float unknown = input.TexCoord1.w;

	float4 albedo = float4(1.0, 0.0, 0.0, 1.0);
	float3 normal = tangentspace_z;
	float3 color = albedo.xyz;
	float alpha = albedo.w;

	float4 c58 = debug_tint;
	float4 c59 = blend_map_xform;
	float4 c60 = global_albedo_tint;
	//float4 c61 = base_map_m_0_xform;
	//float4 c62 = detail_map_m_0_xform;
	//float4 c63 = bump_map_m_0_xform;
	//float4 c64 = detail_bump_m_0_xform;
	//float4 c65 = base_map_m_1_xform;
	//float4 c66 = detail_map_m_1_xform;
	//float4 c67 = bump_map_m_1_xform;
	//float4 c68 = detail_bump_m_1_xform;

	//
	// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
	//
	// Parameters:
	//
	//   sampler2D base_map_m_0;
	//   float4 base_map_m_0_xform;
	//   sampler2D base_map_m_1;
	//   float4 base_map_m_1_xform;
	//   sampler2D blend_map;
	//   float4 blend_map_xform;
	//   sampler2D bump_map_m_0;
	//   float4 bump_map_m_0_xform;
	//   sampler2D bump_map_m_1;
	//   float4 bump_map_m_1_xform;
	//   float4 debug_tint;
	//   sampler2D detail_bump_m_0;
	//   float4 detail_bump_m_0_xform;
	//   sampler2D detail_bump_m_1;
	//   float4 detail_bump_m_1_xform;
	//   sampler2D detail_map_m_0;
	//   float4 detail_map_m_0_xform;
	//   sampler2D detail_map_m_1;
	//   float4 detail_map_m_1_xform;
	//   float global_albedo_tint;
	//
	//
	// Registers:
	//
	//   Name                  Reg   Size
	//   --------------------- ----- ----
	//   debug_tint            c58      1
	//   blend_map_xform       c59      1
	//   global_albedo_tint    c60      1
	//   base_map_m_0_xform    c61      1
	//   detail_map_m_0_xform  c62      1
	//   bump_map_m_0_xform    c63      1
	//   detail_bump_m_0_xform c64      1
	//   base_map_m_1_xform    c65      1
	//   detail_map_m_1_xform  c66      1
	//   bump_map_m_1_xform    c67      1
	//   detail_bump_m_1_xform c68      1
	//   blend_map             s0       1
	//   base_map_m_0          s2       1
	//   detail_map_m_0        s3       1
	//   bump_map_m_0          s4       1
	//   detail_bump_m_0       s5       1
	//   base_map_m_1          s6       1
	//   detail_map_m_1        s7       1
	//   bump_map_m_1          s8       1
	//   detail_bump_m_1       s9       1
	//

	//ps_3_0
	float4 r0, r1, r2, r3, r4, r5, r6;
	float4 oC0, oC1, oC2;

	float4 c0 = float4(2.00787401, -1.00787401, 0, 1); // def c0, 2.00787401, -1.00787401, 0, 1
	float4 c1 = float4(4.59478998, 0.00313080009, 12.92, 1.0 / 2.4); //def c1, 4.59478998, 0.00313080009, 12.9200001, 0.416666657
	float4 c2 = float4(1.055, -0.055, 0.5, 0); //def c2, 1.05499995, -0.0549999997, 0.5, 0

	//dcl_texcoord v0.xy
	//dcl_texcoord1 v1
	//dcl_texcoord2 v2.xyz
	//dcl_texcoord3 v3.xyz
	//dcl_2d s0
	//dcl_2d s2
	//dcl_2d s3
	//dcl_2d s4
	//dcl_2d s5
	//dcl_2d s6
	//dcl_2d s7
	//dcl_2d s8
	//dcl_2d s9


	//{
	//	//mad r2.xy, v0, c59, c59.zwzw
	//	//texld r2, r2, s0


	//	r2 = blend_map_sample;
	//}
	//{
	//	// I think this takes in like two numbers, say 0.5, 0.25, and then normalizes them so they add up to 1.
	//	// This would make sense, otherwise the terrain would be too dark in places

	//	r2.z = ; //add r2.z, r2.y, r2.x
	//	r2.z = 1.0 / r2.z; //rcp r2.z, r2.z
	//	r2.xy = (r2 * r2.z).xy; //mul r2.xy, r2.z, r2
	//}


	float2 blend_map_texcoord = ApplyXForm(texcoord, blend_map_xform);
	float4 blend_map_sample = tex2D(blend_map, blend_map_texcoord);

	float total_blending_weight = 0.0f;
#ifndef flag_material_0_off
	total_blending_weight += blend_map_sample.x;
#endif
#ifndef flag_material_1_off
	total_blending_weight += blend_map_sample.y;
#endif
#ifndef flag_material_2_off
	total_blending_weight += blend_map_sample.z;
#endif
//#ifndef flag_material_3_off
//	total_blending_weight += blend_map_sample.w;
//#endif

	float4 material_blend_weights = blend_map_sample / total_blending_weight;

	float4 aggregate_color = float4(0.0, 0.0, 0.0, 0.0);
#ifndef flag_material_0_off

#endif
#ifndef flag_material_1_off

#endif
#ifndef flag_material_2_off

#endif
#ifndef flag_material_3_off

#endif
	aggregate_color = material_blend_weights;
	if (total_blending_weight == 0) aggregate_color = float4(1.0, 1.0, 1.0, 1.0);

	r3.xyz = aggregate_color.xyz;
	{
		// Crazy bungie color processing that is yet to be determined

		// This appears to be slightly modified to accomodate two different tings
		// debug_tint and global_albedo_tint

		r4.x = c1.x; //mov r4.x, c1.x
		r2.z = r4.x * c60.x; //mul r2.z, r4.x, c60.x
		r4.xyz = r3.xyz * r2.z; //mul r4.xyz, r2.z, r3
		r3.xyz = (r3 * -r2.z + c58).xyz; //mad r3.xyz, r3, -r2.z, c58
		r3.xyz = (r3 * c58.w + r4).xyz; //mad r3.xyz, c58.w, r3, r4

		// I think these might be two seperate parts now. A section for tinting and a section
		// for handling color processing

		//log r4.x, r3.x
		//log r4.y, r3.y
		//log r4.z, r3.z
		r4.xyz = log(r3.xyz); 
		r4.xyz = r4.xyz * c1.w; //mul r4.xyz, r4, c1.w
		//exp r5.x, r4.x
		//exp r5.y, r4.y
		//exp r5.z, r4.z
		r5.xyz = exp(r4.xyz);
		r4.xyz = r5.xyz * c2.x + c2.y; //mad r4.xyz, r5, c2.x, c2.y
		r5.xyz = -r3.xyz + c1.y; //add r5.xyz, -r3, c1.y
		r3.xyz = r3.xyz * c1.z; //mul r3.xyz, r3, c1.z
		
		//cmp oC0.xyz, r5, r3, r4
		oC0.xyz = r5.xyz >= 0 ? r3.xyz : r4.xyz;
	}
	aggregate_color.xyz = oC0.xyz;
	//aggregate_color.xyz = Unknown_Crazy_Bungie_Color_Processing(aggregate_color.xyz);

	PS_OUTPUT output;

	output.Diffuse = aggregate_color;
	output.Normal = float4(NormalExport(tangentspace_z), 1.0);
	output.Unknown = unknown.xxxx;

	return output;











	////{
	////	//mad r0.xy, v0, c65, c65.zwzw
	////	//texld r0, r0, s6

	////	float2 base_map_m_1_texcoord = ApplyXForm(texcoord, base_map_m_1_xform);
	////	float4 base_map_m_1_sample = tex2D(base_map_m_1, base_map_m_1_texcoord);
	////	r0 = base_map_m_1_sample;
	////}
	////{
	////	//mad r1.xy, v0, c66, c66.zwzw
	////	//texld r1, r1, s7

	////	float2 detail_map_m_1_texcoord = ApplyXForm(texcoord, detail_map_m_1_xform);
	////	float4 detail_map_m_1_sample = tex2D(detail_map_m_1, detail_map_m_1_texcoord);
	////	r1 = detail_map_m_1_sample;
	////}
	////r0 = r0 * r1; //mul r0, r0, r1
	////{
	////	//mad r1.xy, v0, c61, c61.zwzw
	////	//texld r1, r1, s2

	////	float2 base_map_m_0_texcoord = ApplyXForm(texcoord, base_map_m_0_xform);
	////	float4 base_map_m_0_sample = tex2D(base_map_m_0, base_map_m_0_texcoord);
	////	r1 = base_map_m_0_sample;
	////}
	////{
	////	//mad r2.xy, v0, c62, c62.zwzw
	////	//texld r2, r2, s3

	////	float2 base_map_m_0_texcoord = ApplyXForm(texcoord, base_map_m_0_xform);
	////	float4 base_map_m_0_sample = tex2D(base_map_m_0, base_map_m_0_texcoord);
	////	r2 = base_map_m_0_sample;
	////}
	////r1 = r1 * r2; //mul r1, r1, r2

	//r1 = r1 * r2.x; //mul r1, r1, r2.x
	//r1 = -r2.x >= 0 ? c0.z : r1.wxyz; //cmp r1, -r2.x, c0.z, r1.wxyz
	//r0 = r1 + r0.wxyz * r2.y; //mad r0, r0.wxyz, r2.y, r1
	//r3.xyz = (-r2.y >= 0 ? r1.yzww : r0.yzww).xyz; //cmp r3.xyz, -r2.y, r1.yzww, r0.yzww
	//
	
	// Crazy bungie shiz
	//{
	//	// Crazy bungie color processing that is yet to be determined

	//	// This appears to be slightly modified to accomodate two different tings
	//	// debug_tint and global_albedo_tint

	//	r4.x = c1.x; //mov r4.x, c1.x
	//	r2.z = r4.x * c60.x; //mul r2.z, r4.x, c60.x
	//	r4.xyz = r3.xyz * r2.z; //mul r4.xyz, r2.z, r3
	//	r3.xyz = (r3 * -r2.z + c58).xyz; //mad r3.xyz, r3, -r2.z, c58
	//	r3.xyz = (r3 * c58.w + r4).xyz; //mad r3.xyz, c58.w, r3, r4

	//	// I think these might be two seperate parts now. A section for tinting and a section
	//	// for handling color processing

	//	//log r4.x, r3.x
	//	//log r4.y, r3.y
	//	//log r4.z, r3.z
	//	r4.xyz = log(r3.xyz); 
	//	r4.xyz = r4.xyz * c1.w; //mul r4.xyz, r4, c1.w
	//	//exp r5.x, r4.x
	//	//exp r5.y, r4.y
	//	//exp r5.z, r4.z
	//	r5.xyz = exp(r4.xyz);
	//	r4.xyz = r5.xyz * c2.x + c2.y; //mad r4.xyz, r5, c2.x, c2.y
	//	r5.xyz = -r3.xyz + c1.y; //add r5.xyz, -r3, c1.y
	//	r3.xyz = r3.xyz * c1.z; //mul r3.xyz, r3, c1.z
	//	
	//	//cmp oC0.xyz, r5, r3, r4
	//	oC0.xyz = r5.xyz >= 0 ? r3.xyz : r4.xyz;
	//}


	//
	//{
	//	// This piece of code samples a bump map + detail map

	//	//mad r2.zw, v0.xyxy, c63.xyxy, c63
	//	//texld r3, r2.zwzw, s4
	//	//mad r2.zw, r3.xyxy, c0.x, c0.y

	//	float2 bump_map_m_0_texcoord = ApplyXForm(texcoord, bump_map_m_0_xform);
	//	float2 bump_map_m_0_sample = normal_x2_sample(bump_map_m_0, bump_map_m_0_texcoord);

	//	//mad r3.xy, v0, c64, c64.zwzw
	//	//texld r3, r3, s5

	//	float2 detail_bump_m_0_texcoord = ApplyXForm(texcoord, detail_bump_m_0_xform);
	//	float4 detail_bump_m_0_sample = tex2D(detail_bump_m_0, detail_bump_m_0_texcoord);

	//	float2 normal2 = bump_map_m_0_sample + detail_bump_m_0_sample.xy * c0.x;
	//	float3 normal = reconstruct_x2_normal(normal2);

	//	//mad r2.zw, r3.xyxy, c0.x, r2
	//	//add r3.yz, r2.xzww, c0.y
	//	//dp2add_sat r2.z, r3.yzzw, r3.yzzw, c0.z
	//	//add r2.z, -r2.z, c0.w
	//	//rsq r2.z, r2.z
	//	//rcp r3.w, r2.z

	//	r3.yzw = normal;
	//}

	//{
	//	//NOTE: r2.xy hold the weights for the layers
	//	//NOTE: This is the X component

	//	// I think this zeroes out the normal if the weight is zero, for some reason? Even though then it wouldn't
	//	// do anything anyway lol cause the weight is zero... Logic

	//	r3.xyz = r3.yzw * r2.x; //mul r3.xyz, r2.x, r3.yzww
	//	r1.yzw = (-r2.x >= 0 ? c0.zzzz : r3.xxyz).xyz; //cmp r1.yzw, -r2.x, c0.z, r3.xxyz
	//}

	//{
	//	// This piece of code samples a bump map + detail map

	//	//mad r2.xz, v0.xyyw, c67.xyyw, c67.zyww
	//	//texld r3, r2.xzzw, s8
	//	//mad r2.xz, r3.xyyw, c0.x, c0.y

	//	float2 bump_map_m_1_texcoord = ApplyXForm(texcoord, bump_map_m_1_xform);
	//	float2 bump_map_m_1_sample = normal_x2_sample(bump_map_m_1, bump_map_m_1_texcoord);

	//	//mad r3.xy, v0, c68, c68.zwzw
	//	//texld r3, r3, s9

	//	float2 detail_bump_m_1_texcoord = ApplyXForm(texcoord, detail_bump_m_1_xform);
	//	float4 detail_bump_m_1_sample = tex2D(detail_bump_m_1, detail_bump_m_1_texcoord);

	//	//mad r2.xz, r3.xyyw, c0.x, r2
	//	//add r3.yz, r2.xxzw, c0.y
	//	//dp2add_sat r2.x, r3.yzzw, r3.yzzw, c0.z
	//	//add r2.x, -r2.x, c0.w
	//	//rsq r2.x, r2.x
	//	//rcp r3.w, r2.x

	//	r3.yzw = normal;
	//}
	//{
	//	//NOTE: r2.xy hold the weights for the layers
	//	//NOTE: This is the Y component 
	//	//NOTE: r1 contains the result from the first bump map sampling

	//	r0.yzw = (r3 * r2.y + r1).xyz; //mad r0.yzw, r3, r2.y, r1
	//	r0 = (-r2.y >= 0 ? r1.yzwx : r0.yzwx); //cmp r0, -r2.y, r1.yzwx, r0.yzwx

	//	//NOTE: r0 is not the aggregated normal
	//}
	//{
	//	//nrm r1.xyz, r0
	//	//nrm r0.xyz, v2
	//	//mul r0.xyz, r0, r1.y
	//	//nrm r2.xyz, v3
	//	//mad r0.xyz, r1.x, r2, r0
	//	//nrm r2.xyz, v1
	//	//mad r0.xyz, r1.z, r2, r0

	//	r0.xyz = TangentSpaceToModelSpace(tangentspace_x, tangentspace_y, tangentspace_z, r0.xyz);
	//}
	//{
	//	//mad oC1.xyz, r0, c2.z, c2.z
	//	//mov oC0.w, r0.w
	//	//mov oC1.w, r0.w
	//	//mov oC2, v1.w

	//	oC1.xyz = NormalExport(r0.xyz);
	//	oC0.w = r0.w;
	//	oC1.w = r0.w;
	//	oC2 = unknown.xxxx;

	//	PS_OUTPUT output;

	//	output.Diffuse = oC0;
	//	output.Normal = oC1;
	//	output.Unknown = oC2;

	//	return output;
	//}


	//BLEND MAP TEST CODE START



	//mad r2.xy, v0, c59, c59.zwzw
	//texld r2, r2, s0

	//float2 blend_map_texcoord = ApplyXForm(texcoord, blend_map_xform);
	//float4 blend_map_sample = tex2D(blend_map, blend_map_texcoord);

	//PS_OUTPUT output;

	//output.Diffuse = blend_map_sample;
	//output.Normal = float4(NormalExport(tangentspace_z), blend_map_sample.w);
	//output.Unknown = unknown.xxxx;

	//return output;


	// BLEND MAP TEST CODE END
}
