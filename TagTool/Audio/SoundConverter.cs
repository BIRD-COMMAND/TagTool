using System;
using System.Diagnostics;
using System.IO;
using TagTool.Audio.Converter;
using TagTool.Cache;
using TagTool.Common;
using TagTool.IO;
using TagTool.Tags.Definitions;

namespace TagTool.Audio
{
    public static class SoundConverter
    {
        private static readonly string BaseFileName = "temp";
        private static readonly string XMAFile = BaseFileName + ".xma";
        private static readonly string WAVFile = BaseFileName + ".wav";
        private static readonly string MP3File = BaseFileName + ".mp3";
        private static readonly string FSBFile = BaseFileName + ".fsb";
        private static readonly string OGGFile = BaseFileName + ".ogg";

        //file names for multi channel files generated by towav
        private static readonly string WAV1FlUnk = BaseFileName + " 1 Fl Unk.wav";
        private static readonly string WAV2BlUnk = BaseFileName + " 2 Bl Unk.wav";

        private static readonly string WAV2CUnk = BaseFileName + " 2 C Unk.wav";
        private static readonly string WAV3BlUnk = BaseFileName + " 3 Bl Unk.wav";

        public static BlamSound ConvertGen3Sound(GameCache cache, SoundCacheFileGestalt soundGestalt, Sound sound, int pitchRangeIndex, int permutationIndex, byte[] data, Compression targetFormat)
        {
            ClearFiles();
            BlamSound blamSound = GetXMA(cache, soundGestalt, sound, pitchRangeIndex, permutationIndex, data);

            var channelCount = Encoding.GetChannelCount(blamSound.Encoding);
            var sampleRate = blamSound.SampleRate.GetSampleRateHz();

            WriteXMAFile(blamSound);

            if(targetFormat == Compression.MP3)
            {
                if (channelCount > 2)
                {
                    // channelCount is 4 or 6
                    ConvertToWAV(XMAFile, false);
                    byte[] originalWAVdata = File.ReadAllBytes(WAVFile);
                    byte[] truncatedWAVdata = TruncateWAVFile(originalWAVdata, sampleRate, channelCount, 0x4E);
                    blamSound.UpdateFormat(Compression.PCM, truncatedWAVdata);
                }
                else
                {
                    ConvertToWAV(XMAFile, true);
                    blamSound.UpdateFormat(Compression.PCM, LoadWAVData(WAVFile, -1, false));
                }
                WriteWAVFile(blamSound);
                ConvertToMP3(WAVFile);
                blamSound.UpdateFormat(Compression.MP3, File.ReadAllBytes(MP3File));
            }
            else if(targetFormat == Compression.PCM)
            {
                ConvertToWAV(XMAFile, channelCount > 2 ? false: true);
                blamSound.UpdateFormat(Compression.PCM, PrepareWAVForFMOD(WAVFile));
            }

            ClearFiles();
            return blamSound;
        }

        public static BlamSound GetXMA(GameCache cache, SoundCacheFileGestalt soundGestalt, Sound sound, int pitchRangeIndex, int permutationIndex, byte[] data)
        {
            int pitchRangeGestaltIndex = sound.SoundReference.PitchRangeIndex + pitchRangeIndex;
            int permutationGestaltIndex = soundGestalt.PitchRanges[pitchRangeGestaltIndex].FirstPermutationIndex + permutationIndex;

            var permutationSize = soundGestalt.GetPermutationSize(permutationGestaltIndex);
            var permutationOffset = soundGestalt.GetPermutationOffset(permutationGestaltIndex);
            byte[] permutationData = new byte[permutationSize];
            Array.Copy(data, permutationOffset, permutationData, 0, permutationSize);

            return new BlamSound(sound, permutationGestaltIndex, permutationData, cache.Version, soundGestalt);
        }

        private static void ConvertToWAVWithXMADec(string XMAFileName)
        {
            ProcessStartInfo info = new ProcessStartInfo(@"Tools\xmadec.exe")
            {
                Arguments = XMAFileName + " " + WAVFile,
                CreateNoWindow = true,
                WindowStyle = ProcessWindowStyle.Hidden,
                UseShellExecute = false,
                RedirectStandardError = false,
                RedirectStandardOutput = false,
                RedirectStandardInput = false
            };
            Process ffmpeg = Process.Start(info);
            ffmpeg.WaitForExit();
        }

        private static void ConvertToWAV(string XMAFileName, bool useTowav = true)
        {
            if (useTowav)
            {
                ProcessStartInfo info = new ProcessStartInfo(@"Tools\towav.exe")
                {
                    Arguments = " " + XMAFileName,
                    CreateNoWindow = true,
                    WindowStyle = ProcessWindowStyle.Hidden,
                    UseShellExecute = false,
                    RedirectStandardError = false,
                    RedirectStandardOutput = false,
                    RedirectStandardInput = false
                };
                Process towav = Process.Start(info);
                towav.WaitForExit();
            }
            else
            {
                ProcessStartInfo info = new ProcessStartInfo(@"Tools\ffmpeg.exe")
                {
                    Arguments = "-i " + XMAFileName + " -q:a 0 " +WAVFile,
                    CreateNoWindow = true,
                    WindowStyle = ProcessWindowStyle.Hidden,
                    UseShellExecute = false,
                    RedirectStandardError = false,
                    RedirectStandardOutput = false,
                    RedirectStandardInput = false
                };
                Process ffmpeg = Process.Start(info);
                ffmpeg.WaitForExit();
            }
            
        }

        private static void ConvertToMP3(string WAVFileName)
        {
            ProcessStartInfo info = new ProcessStartInfo(@"Tools\ffmpeg.exe")
            {
                Arguments = "-i " + WAVFileName + " -q:a 0 " + MP3File,
                CreateNoWindow = true,
                WindowStyle = ProcessWindowStyle.Hidden,
                UseShellExecute = false,
                RedirectStandardError = false,
                RedirectStandardOutput = false,
                RedirectStandardInput = false
            };
            Process ffmpeg = Process.Start(info);
            ffmpeg.WaitForExit();
        }

        private static void WriteXMAFile(BlamSound blamSound)
        {
            using (EndianWriter output = new EndianWriter(new FileStream(XMAFile, FileMode.Create, FileAccess.Write, FileShare.None), EndianFormat.BigEndian))
            {
                XMAFile XMAfile = new XMAFile(blamSound);
                XMAfile.Write(output);
            }
        }

        private static void WriteWAVFile(BlamSound blamSound)
        {
            using (EndianWriter output = new EndianWriter(new FileStream(WAVFile, FileMode.Create, FileAccess.Write, FileShare.None), EndianFormat.BigEndian))
            {
                WAVFile WAVfile = new WAVFile(blamSound);
                WAVfile.Write(output);
            }
        }

        private static void ClearFiles()
        {
            DeleteFile(XMAFile);
            DeleteFile(WAVFile);
            DeleteFile(MP3File);
            DeleteFile(FSBFile);
            DeleteFile(WAV1FlUnk);
            DeleteFile(WAV2BlUnk);
            DeleteFile(WAV2CUnk);
            DeleteFile(WAV3BlUnk);
            DeleteFile(OGGFile);
        }

        private static void DeleteFile(string name)
        {
            if (File.Exists(name))
                File.Delete(name);
        }

        private static byte[] TruncateWAVFile(byte[] data, int sampleRate, int channelCount, int additionalOffset = 0)
        {
            var bytesPerSample = 2;         //16 bit PCM
            int startOffset = (0x240 * channelCount * bytesPerSample);                       // Offset from index 0 
            int endOffset = (0xBE * channelCount * bytesPerSample);                                           // Offset from index data.Length -1
            if (channelCount == 1)
                endOffset = 0;

            int size = data.Length - startOffset - endOffset - additionalOffset;
            byte[] result = new byte[size];
            Array.Copy(data, startOffset + additionalOffset, result, 0, size);
            return result;
        }

        private static long FindRiffChunk(Stream stream, string id, out long chunkSize)
        {
            chunkSize = 0;

            long offset = -1;
            byte[] header = new byte[8];

            do
            {
                if (stream.Read(header, 0, header.Length) != header.Length)
                    break;

                string currentChunkId = System.Text.Encoding.ASCII.GetString(header, 0, 4);
                uint currentChunkSize = BitConverter.ToUInt32(header, 4);

                if (currentChunkId == id)
                {
                    chunkSize = currentChunkSize;
                    offset = stream.Position;
                }

                stream.Position += currentChunkId == "RIFF" ? 4 : currentChunkSize;
            } 
            while (offset < 0);

            return offset;
        }

        private static byte[] PrepareWAVForFMOD(string name)
        {
            using (var stream = File.OpenRead(name))
            {
                long dataOffset = FindRiffChunk(stream, "data", out long dataSize);
                byte[] result = new byte[dataSize + 0x20];
                stream.Position = dataOffset;
                stream.Read(result, 0x10, (int)dataSize);
                return result;
            }
        }

        private static byte[] LoadWAVData(string name, int length, bool matchLength=true)
        {
            var fileLength = new FileInfo(name).Length - 0x2E;
            byte[] result = null;
            if (matchLength)
            {
                if (fileLength > length)
                    fileLength = length;

                result = new byte[length];
                byte[] data = File.ReadAllBytes(name);
                // length-fileLength != 0 when merging multi channel files, otherwise they are equal and fileLengtth - 0x2E is the actual length of the wav data.
                Array.Copy(data, 0x2E, result, length - fileLength, fileLength);
            }
            else
            {
                byte[] data = File.ReadAllBytes(name);
                result = new byte[fileLength];
                Array.Copy(data, 0x2E, result, 0, fileLength);
            }
            return result;
        }

    }
}
